# Docker
Docker - это средство виртуализации. Одно из назначений которого виртуализация рабочих сред на серверах.
Также он предоставляет универсальный способ доставки приложений на машины (локальный компьютер или удаленные сервера) 
и их запуска в изолированном окружении.

**Основные понятия:**
* **Образ** — самостоятельная файловая система. Пока мы используем готовые образы, но потом научимся создавать их самостоятельно.
* **Контейнер** — запущенный процесс операционной системы в изолированном окружении с подключенной файловой системой из образа.

Контейнер — всего лишь обычный процесс вашей операционной системы. 
Разница лишь в том, что благодаря возможностям ядра докер стартует процесс в изолированном окружении. 
Контейнер видит свой собственный список процессов, свою собственную сеть, свою собственную файловую систему и так далее. 
Пока ему не укажут явно, он не может взаимодействовать с вашей основной операционной системой и всем, что в ней хранится или запущено.

## Основные команды
Список основных команд, которые могут пригодиться в работе:
```java
//Список всех команд можно получить просто набрав:
> docker

//Pull контейнеров
> docker pull bellsoft/liberica-openjdk-alpine

/* Просмотр всех образов, что скачаны на машину разработчика
Образ состоит из слоев. Каждая модификация образа выделяется в отдельный слой. 
*/
> docker images

//Просмотр всех контейнеров (запущенных или уже остановленных)
> docker ps -a

/* Чтобы стартовать image надо его загрузить в контейнер, это можно сделать следующим способом:
Где ключ it - интерактивный терминал 
*/
> docker run -it bellsoft/liberica-openjdk-alpine:latest 

//Докер контейнер работает ровно столько, сколько работает команда по умолчанию, либо та с которой его запустил пользователь
> docker run -it bellsoft/liberica-openjdk-alpine:latest java -version

//Удаление контейнеров: по имени/ИД или всех разом:
> docker rm CONTAINER ID/NAMES
> docker rm $(docker ps -aq) //удалить все контейнеры, флаг q - только ИД выводить

//Удаление образов, которые загружены (Образы, которые используются контейнерами - не будут удалены!) 
> docker rmi $(docker images -q)

//Можно стартануть уже существующий контейнер:
> docker start NAME

//Подключение и выполнение команды у работающего контейнера:
> docker exec -it NAME sh

/* Контейнеры, по-умолчанию, работают в полностью изолированном окружении, 
если мы хотим к ним подключиться из вне, нужно, пробросить порты.

Также здесь есть подключение volume для работы с файловой системой и использование переменных окружения, которые задал автор образа. 
*/
> docker run -d -p 1521:1521 -p 81:81 -v c:\data\temp:/opt/h2-data -e H2_OPTIONS='-ifNotExists' --name=h2 oscarfonts/h2
> docker run -d -p 1521:1521 -p 81:81 -v h2_db:/opt/h2-data -e H2_OPTIONS='-ifNotExists' --name=h2 oscarfonts/h2

```
## Создание образа
Образ создается с помощью файла dockerfile. 

```java
//Пример докерфайла для Java-приложения:

FROM openjdk
COPY build/libs/docker-1.0-SNAPSHOT.jar service.jar
CMD java $JAVA_OPTS -jar /service.jar $ARGS
EXPOSE 8080

//Пример команды для билда image из докерфайла:
>docker build -t app:latest .
```

## Jib
Jib-plugin ([On github](https://github.com/GoogleContainerTools/jib)) 
- простой и удобный инструмент для создания образов напрямую через ваш инструмент сборки: maven/gradle 

```java
// Пример конфигурирования плагина для приложения 'docker'
jib {
    from {
        image = 'openjdk'
    }
    to {
        image = 'dgradle'
        tags = [version, 'latest']
    }
    container {
        ports = ['8080']
        args = ['']
    }
}

// Далее билдим 
> ./gradlew jibDockerBuild

// Запускаем 
> docker run dgradle:latest name

```
## Docker-compose
Позволяет запускать цепочку контейнеров в едином файле. 
Пример представлен в файле [docker-compose.yml](x.x-docker/docker-compose/docker-compose.yml)

**Основные команды:**
```java
//Запуск compose файла
> docker-compose up 

//Останов compose файла
> docker-compose  down 

//Отображение логов 
> docker-compose logs


```

## Задание 
Сделать докер-контейнеры из сервисов `client-service` и `admin-service` связать их посредством 
`docker-compose` файла, чтобы `admin-service` мог зарегистрировать в себе `client-service`
Далее, связать в одном docker-compose файле 4-приложения:
* client-service
* admin-service
* mongodb
* mongo-express

чтобы вся цепочка сервисов успешно работала. 